# Copyright (c) 2021, NVIDIA CORPORATION.
import numpy as np


class Reducible:
    """Mixin encapsulating for reduction operations.

    Various classes in cuDF support
    `reductions <https://en.wikipedia.org/wiki/Reduction_Operator>`__.  In
    practice the reductions are implemented via dispatch to a lower-level API.
    For example, Frame-like objects dispatch to Columns, which in turn dispatch
    to libcudf implementations. As a result, rather than encoding the logic for
    different types of reductions, most classes can implement all reductions
    in terms of a single function that performs necessary pre- and
    post-processing of a result generated by calling to a lower-level API. This
    class encapsulates that paradigm.
    """

    # TODO: We need a way to indicate supported/unsupported operations.
    # Alternatively, we could just leave that up to the implementation of
    # _reduce.
    # TODO: If supported operations are indicated using a class member list
    # (_SUPPORTED_OPERATIONS or so) we could use __init_subclass__ to combine
    # all parent lists via walking the MRO.

    def _reduce(self, op: str, *args, **kwargs):
        raise NotImplementedError

    def sum(self, *args, **kwargs):
        return self._reduce("sum", *args, **kwargs)

    def product(self, *args, **kwargs):
        return self._reduce("product", *args, **kwargs)

    # def min(self, *args, **kwargs):
    #     return self._reduce("min", *args, **kwargs)
    #
    # def max(self, *args, **kwargs):
    #     return self._reduce("max", *args, **kwargs)

    # def count(self, *args, **kwargs):
    #     return self._reduce("count", *args, **kwargs)
    #
    # def size(self, *args, **kwargs):
    #     return self._reduce("size", *args, **kwargs)
    #
    # def any(self, *args, **kwargs):
    #     return self._reduce("any", *args, **kwargs)
    #
    # def all(self, *args, **kwargs):
    #     return self._reduce("all", *args, **kwargs)

    def sum_of_squares(self, *args, **kwargs):
        return self._reduce("sum_of_squares", *args, **kwargs)

    # TODO: Need a better way of setting a default dtype. If nothing else, I
    # guess we'll just need to override this parameter in the relevant column
    # types (numerical_base).
    def mean(self, dtype=np.float64, *args, **kwargs):
        return self._reduce("mean", dtype=dtype, *args, **kwargs)

    def var(self, dtype=np.float64, *args, **kwargs):
        return self._reduce("var", dtype=dtype, *args, **kwargs)

    def std(self, dtype=np.float64, *args, **kwargs):
        return self._reduce("std", dtype=dtype, *args, **kwargs)

    # def median(self, *args, **kwargs):
    #     return self._reduce("median", *args, **kwargs)
    #
    # def quantile(self, *args, **kwargs):
    #     return self._reduce("quantile", *args, **kwargs)
    #
    # def argmax(self, *args, **kwargs):
    #     return self._reduce("argmax", *args, **kwargs)
    #
    # def argmin(self, *args, **kwargs):
    #     return self._reduce("argmin", *args, **kwargs)
    #
    # def nunique(self, *args, **kwargs):
    #     return self._reduce("nunique", *args, **kwargs)
    #
    # def nth(self, *args, **kwargs):
    #     return self._reduce("nth", *args, **kwargs)

    # def collect(self, *args, **kwargs):
    #     return self._reduce("sum", *args, **kwargs)
    #
    # def unique(self, *args, **kwargs):
    #     return self._reduce("sum", *args, **kwargs)
