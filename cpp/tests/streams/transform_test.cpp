/*
 * Copyright (c) 2024, NVIDIA CORPORATION.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#include <cudf_test/base_fixture.hpp>
#include <cudf_test/column_wrapper.hpp>
#include <cudf_test/default_stream.hpp>

#include <cudf/ast/expressions.hpp>
#include <cudf/column/column_view.hpp>
#include <cudf/transform.hpp>
#include <cudf/types.hpp>

class TransformTest : public cudf::test::BaseFixture {};

template <class dtype, class Data>
void test_udf(char const* udf, Data data_init, cudf::size_type size, bool is_ptx)
{
  auto all_valid = cudf::detail::make_counting_transform_iterator(0, [](auto i) { return true; });
  auto data_iter = cudf::detail::make_counting_transform_iterator(0, data_init);
  cudf::test::fixed_width_column_wrapper<dtype, typename decltype(data_iter)::value_type> in(
    data_iter, data_iter + size, all_valid);
  cudf::transform({in},
                  udf,
                  cudf::data_type(cudf::type_to_id<dtype>()),
                  is_ptx,
                  cudf::test::get_default_stream());
}

TEST_F(TransformTest, Transform)
{
  char const* cuda =
    R"***(
__device__ inline void    fdsf   (
       int64_t i,
       float * out,
       float const* in
)
{
  float const a = in[i];
  out[i] = a*a*a*a;
}
)***";

  char const* ptx =
    R"***(
//
// Generated by NVIDIA NVVM Compiler
//
// Compiler Build ID: CL-34841621
// Cuda compilation tools, release 12.6, V12.6.77
// Based on NVVM 7.0.1
//

.version 8.5
.target sm_70
.address_size 64

.func _Z4fdsflPfPKf(
        .param .b64 _Z4fdsflPfPKf_param_0,
        .param .b64 _Z4fdsflPfPKf_param_1,
        .param .b64 _Z4fdsflPfPKf_param_2
)
{
        .reg .f32       %f<5>;
        .reg .b64       %rd<9>;


        ld.param.u64    %rd1, [_Z4fdsflPfPKf_param_0];
        ld.param.u64    %rd2, [_Z4fdsflPfPKf_param_1];
        ld.param.u64    %rd3, [_Z4fdsflPfPKf_param_2];
        cvta.to.global.u64      %rd4, %rd2;
        cvta.to.global.u64      %rd5, %rd3;
        shl.b64         %rd6, %rd1, 2;
        add.s64         %rd7, %rd5, %rd6;
        ld.global.f32   %f1, [%rd7];
        mul.f32         %f2, %f1, %f1;
        mul.f32         %f3, %f1, %f2;
        mul.f32         %f4, %f1, %f3;
        add.s64         %rd8, %rd4, %rd6;
        st.global.f32   [%rd8], %f4;
        ret;

}
)***";

  auto data_init = [](cudf::size_type row) { return row % 3; };
  test_udf<float>(cuda, data_init, 500, false);
  test_udf<float>(ptx, data_init, 500, true);
}

TEST_F(TransformTest, ComputeColumn)
{
  auto c_0        = cudf::test::fixed_width_column_wrapper<cudf::size_type>{3, 20, 1, 50};
  auto c_1        = cudf::test::fixed_width_column_wrapper<cudf::size_type>{10, 7, 20, 0};
  auto table      = cudf::table_view{{c_0, c_1}};
  auto col_ref_0  = cudf::ast::column_reference(0);
  auto col_ref_1  = cudf::ast::column_reference(1);
  auto expression = cudf::ast::operation(cudf::ast::ast_operator::ADD, col_ref_0, col_ref_1);
  cudf::compute_column(table, expression, cudf::test::get_default_stream());
}

TEST_F(TransformTest, BoolsToMask)
{
  std::vector<bool> input({1, 0, 1, 0, 1, 0, 1, 0});
  cudf::test::fixed_width_column_wrapper<bool> input_column(input.begin(), input.end());
  cudf::bools_to_mask(input_column, cudf::test::get_default_stream());
}

TEST_F(TransformTest, MaskToBools)
{
  cudf::mask_to_bools(nullptr, 0, 0, cudf::test::get_default_stream());
}

TEST_F(TransformTest, Encode)
{
  cudf::test::fixed_width_column_wrapper<cudf::size_type> input{{1, 2, 3, 2, 3, 2, 1}};
  cudf::encode(cudf::table_view({input}), cudf::test::get_default_stream());
}

TEST_F(TransformTest, OneHotEncode)
{
  auto input    = cudf::test::fixed_width_column_wrapper<cudf::size_type>{8, 8, 8, 9, 9};
  auto category = cudf::test::fixed_width_column_wrapper<cudf::size_type>{8, 9};
  cudf::one_hot_encode(input, category, cudf::test::get_default_stream());
}

TEST_F(TransformTest, NaNsToNulls)
{
  std::vector<float> input = {1, 2, 3, 4, 5};
  std::vector<bool> mask   = {true, true, true, true, false, false};
  auto input_column =
    cudf::test::fixed_width_column_wrapper<float>(input.begin(), input.end(), mask.begin());
  cudf::nans_to_nulls(input_column, cudf::test::get_default_stream());
}

TEST_F(TransformTest, RowBitCount)
{
  std::vector<std::string> strings{"abc", "ï", "", "z", "bananas", "warp", "", "zing"};
  cudf::test::strings_column_wrapper col(strings.begin(), strings.end());
  cudf::row_bit_count(cudf::table_view({col}), cudf::test::get_default_stream());
}

TEST_F(TransformTest, SegmentedRowBitCount)
{
  // clang-format off
  std::vector<std::string> const strings { "daïs", "def", "", "z", "bananas", "warp", "", "zing" };
  std::vector<bool>        const valids  {  1,      0,    0,  1,   0,          1,      1,  1 };
  // clang-format on
  cudf::test::strings_column_wrapper const col(strings.begin(), strings.end(), valids.begin());
  auto const input              = cudf::table_view({col});
  auto constexpr segment_length = 2;
  cudf::segmented_row_bit_count(input, segment_length, cudf::test::get_default_stream());
}
