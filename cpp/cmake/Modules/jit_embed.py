# SPDX-FileCopyrightText: Copyright (c) 2026, NVIDIA CORPORATION. All rights reserved.
# SPDX-License-Identifier: Apache-2.0
import argparse
import hashlib
from typing import NamedTuple, Self

import yaml

BYTE_TYPE = "unsigned char"
SIZE_TYPE = "unsigned long"
STORAGE_SPEC = "static constexpr"
LIST_LINE_WIDTH = 32
NAMESPACE_PREFIX = "jit_"

### json schema

"""entries
[
    $id: {
        "type": "sources",
        "sources": [
            {
                "file": string,
                "dest": string
            }
        ],
        "include_directories": [string]
    },
    $id: {
        "type": "strings",
        "strings": list[string]
    }
]
"""


PREAMBLE = f"""
/// Auto-generated by jit_embed.py. Do not edit directly.
#pragma once

extern "C" {{

typedef struct {NAMESPACE_PREFIX}byte_array_t {{
    {BYTE_TYPE} const * data;
    {SIZE_TYPE} size;
}} {NAMESPACE_PREFIX}byte_array_t;

typedef struct {NAMESPACE_PREFIX}array_of_byte_arrays_t {{
    {BYTE_TYPE} const * const * elements;
    {SIZE_TYPE} const * element_sizes;
    {SIZE_TYPE} size;
}} {NAMESPACE_PREFIX}array_of_byte_arrays_t;

}}

"""


def list_string(strings: list[str]) -> str:
    lines = []
    for i in range(0, len(strings), LIST_LINE_WIDTH):
        line = ", ".join(strings[i : i + LIST_LINE_WIDTH])
        lines.append(line)
    return ",\n".join(lines)


def hex_string(value: int) -> str:
    return f"0x{value:02X}"


class CXXVarDecl(NamedTuple):
    id: str
    expr: str

    def code(self: Self) -> str:
        return f"""{self.expr}"""

    @staticmethod
    def of_bytes(id: str, data: bytes, alignment: int) -> Self:
        byte_array = list_string([hex_string(b) for b in data])
        expr = f"""alignas({alignment}) {STORAGE_SPEC} {BYTE_TYPE} const {id}[{len(data)}] = {{
{byte_array}
}};"""
        return CXXVarDecl(id=id, expr=expr)

    @staticmethod
    def of_size(id: str, size: int) -> Self:
        expr = f"{STORAGE_SPEC} {SIZE_TYPE} const {id} = {size}ULL;"
        return CXXVarDecl(id=id, expr=expr)


class CXXSizeArrayDecl(NamedTuple):
    id: str
    sizes: list[int]

    def decl(self: Self) -> CXXVarDecl:
        size_array = list_string([f"{size}ULL" for size in self.sizes])
        expr = f"""{STORAGE_SPEC} {SIZE_TYPE} const {self.id}[{len(self.sizes)}] = {{
{size_array}
}};"""
        return CXXVarDecl(id=self.id, expr=expr)

    @staticmethod
    def of_sizes(id: str, sizes: list[int]) -> Self:
        return CXXSizeArrayDecl(id=id, sizes=sizes)


class CXXByteArrayDecl(NamedTuple):
    id: str
    data: CXXVarDecl
    size: CXXVarDecl

    def decl(self: Self) -> CXXVarDecl:
        return CXXVarDecl(
            id=self.id,
            expr=f"""
{self.data.code()}

{self.size.code()}


{STORAGE_SPEC} {NAMESPACE_PREFIX}byte_array_t const {self.id} = {{
    {self.data.id},
    {self.size.id}
}};
""",
        )

    @staticmethod
    def of_bytes(
        id: str, data: bytes, alignment: int, num_null_terminators: int
    ) -> Self:
        # exclude null terminator from length
        size_decl = CXXVarDecl.of_size(id=f"{id}_size", size=len(data))

        data += b"\0" * num_null_terminators

        data_decl = CXXVarDecl.of_bytes(
            id=f"{id}_data", data=data, alignment=alignment
        )

        return CXXByteArrayDecl(id=id, data=data_decl, size=size_decl)


class CXXArrayOfByteArraysDecl(NamedTuple):
    id: str
    elements: list[CXXByteArrayDecl]
    size: CXXVarDecl

    def decl(self: Self) -> CXXVarDecl:
        elements_decl = "\n".join(e.decl().code() for e in self.elements)
        count = len(self.elements)
        data_ids = ", ".join([d.data.id for d in self.elements])
        size_ids = ", ".join([d.size.id for d in self.elements])

        return CXXVarDecl(
            id=self.id,
            expr=f"""
{elements_decl}

{STORAGE_SPEC} {BYTE_TYPE} const * const {self.id}_elements[{count}] = {{ {data_ids} }};
{STORAGE_SPEC} {SIZE_TYPE} const {self.id}_element_sizes[{count}] = {{ {size_ids} }};


{STORAGE_SPEC} {NAMESPACE_PREFIX}array_of_byte_arrays_t const {self.id} = {{
    {self.id}_elements,
    {self.id}_element_sizes,
    {count}ULL
}};
""",
        )

    @staticmethod
    def of_bytes_array(
        id: str,
        data_list: list[bytes],
        data_alignment: int,
        num_null_terminators: int,
    ) -> Self:
        size = len(data_list)
        size_decl = CXXVarDecl.of_size(id=f"{id}_size", size=size)
        array_decls: list[CXXByteArrayDecl] = [
            CXXByteArrayDecl.of_bytes(
                id=f"{id}_element_{i}",
                data=data,
                alignment=data_alignment,
                num_null_terminators=num_null_terminators,
            )
            for i, data in enumerate(data_list)
        ]

        return CXXArrayOfByteArraysDecl(
            id=id, elements=array_decls, size=size_decl
        )


def generate_cxx_string_data(id: str, strings: list[str]) -> str:
    arrays: list[bytes] = [s.encode("utf-8") for s in strings]

    # compute combined sha256 hash of all strings
    sha = hashlib.sha256()
    for arr in arrays:
        sha.update(arr)
    data_hash: bytes = sha.digest()

    arrays_decl = CXXArrayOfByteArraysDecl.of_bytes_array(
        id=f"{id}", data_list=arrays, data_alignment=1, num_null_terminators=1
    )

    data_hash_decl: CXXByteArrayDecl = CXXByteArrayDecl.of_bytes(
        id=f"{id}_data_hash",
        data=data_hash,
        alignment=1,
        num_null_terminators=0,
    )

    return f"""
{arrays_decl.decl().code()}

{data_hash_decl.decl().code()}
"""


def generate_cxx_source_files_data(
    id: str,
    file_paths: list[str],
    dests: list[str],
    include_directories: list[str] = [],
) -> str:
    files_bytes: list[bytes] = []

    # compute combined sha256 hash of all files
    sha = hashlib.sha256()

    for file_path in file_paths:
        with open(file_path, "rb") as f:
            data = f.read()
            sha.update(data)
        files_bytes.append(data)

    file_data_hash: bytes = sha.digest()

    file_destinations_decls: CXXArrayOfByteArraysDecl = (
        CXXArrayOfByteArraysDecl.of_bytes_array(
            id=f"{id}_file_destinations",
            data_list=[f.encode("utf-8") for f in dests],
            data_alignment=1,
            num_null_terminators=1,
        )
    )

    file_data_decl: CXXArrayOfByteArraysDecl = (
        CXXArrayOfByteArraysDecl.of_bytes_array(
            id=f"{id}_file_data",
            data_list=files_bytes,
            data_alignment=1,
            num_null_terminators=1,
        )
    )

    file_data_hash_decl: CXXByteArrayDecl = CXXByteArrayDecl.of_bytes(
        id=f"{id}_file_data_hash",
        data=file_data_hash,
        alignment=1,
        num_null_terminators=0,
    )

    file_size_decls: CXXSizeArrayDecl = CXXSizeArrayDecl.of_sizes(
        id=f"{id}_file_sizes",
        sizes=[len(f) for f in files_bytes],
    )

    include_directories_decls: CXXArrayOfByteArraysDecl = (
        CXXArrayOfByteArraysDecl.of_bytes_array(
            id=f"{id}_include_directories",
            data_list=[d.encode("utf-8") for d in include_directories],
            data_alignment=1,
            num_null_terminators=1,
        )
    )

    return f"""
{file_destinations_decls.decl().code()}

{file_data_decl.decl().code()}

{file_data_hash_decl.decl().code()}

{file_size_decls.decl().code()}

{include_directories_decls.decl().code()}
"""


# TODO: write a schema validator for the input YAML


def generate_embed_source(entries: dict[str, dict[str, dict]]) -> str:
    code: str = ""

    for entry_id, entry_value in entries.items():
        entry_type = entry_value["type"]

        if entry_type == "sources":
            sources: list[dict] = entry_value["sources"]
            file_paths = [s["file"] for s in sources]
            dests = [s["dest"] for s in sources]
            include_directories: list[str] = entry_value["include_directories"]
            code += generate_cxx_source_files_data(
                entry_id, file_paths, dests, include_directories
            )

        elif entry_type == "strings":
            options: list[str] = entry_value["strings"]
            code += generate_cxx_string_data(entry_id, options)

        else:
            raise ValueError(f"Unknown type: {entry_type}")

    return f"""
{PREAMBLE}

extern "C" {{

{code}

}}

"""


# Usage: embed.py --input <input file> --output <output file>
def main():
    parser = argparse.ArgumentParser(
        description="Embed headers, options, or binary blobs into C++ source code."
    )

    parser.add_argument(
        "--input",
        type=str,
        required=True,
        help="YAML description of what to embed",
    )

    parser.add_argument(
        "--output", type=str, required=True, help="Output C++ source file"
    )

    args = parser.parse_args()

    with open(args.input, "rb") as f:
        description = yaml.safe_load(f)
    code = generate_embed_source(description)

    with open(args.output, "w") as f:
        f.write(code)


if __name__ == "__main__":
    main()
