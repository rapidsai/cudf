/*
 * Copyright (c) 2018-2019, NVIDIA CORPORATION.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#include <cudf/cudf.h>
#include <bitmask/legacy/legacy_bitmask.hpp>
#include <cassert>
#include <cudf/copying.hpp>
#include <cudf/table.hpp>
#include <utilities/column_utils.hpp>
#include <utilities/error_utils.hpp>

#include <algorithm>

namespace cudf {

table::table(std::vector<gdf_column*> const& cols) : _columns{cols} {
  CUDF_EXPECTS(nullptr != cols[0], "Null input column");
  gdf_size_type num_rows = cols[0]->size;

  std::for_each(_columns.begin(), _columns.end(),
                [this, num_rows](gdf_column* col) {
                  CUDF_EXPECTS(nullptr != col, "Null input column");
                  CUDF_EXPECTS(num_rows == col->size, "Column size mismatch");
                });
}

table::table(std::initializer_list<gdf_column*> list)
    : table{std::vector<gdf_column*>(list)} {}

table::table(gdf_column* cols[], gdf_size_type num_cols)
    : table{std::vector<gdf_column*>(cols, cols + num_cols)} {}

table::table(gdf_size_type num_rows, std::vector<gdf_dtype> const& dtypes,
             bool allocate_bitmasks, bool all_valid, cudaStream_t stream)
    : _columns(dtypes.size()) {
  std::transform(
      _columns.begin(), _columns.end(), dtypes.begin(), _columns.begin(),
      [num_rows, allocate_bitmasks, all_valid, stream](gdf_column*& col,
                                                       gdf_dtype dtype) {
        CUDF_EXPECTS(dtype != GDF_invalid, "Invalid gdf_dtype.");
        CUDF_EXPECTS(dtype != GDF_TIMESTAMP, "Timestamp unsupported.");
        col = new gdf_column{};
        col->size = num_rows;
        col->dtype = dtype;
        col->null_count = 0;
        col->valid = nullptr;

        // Timestamp currently unsupported as it would require passing in
        // additional resolution information
        gdf_dtype_extra_info extra_info{TIME_UNIT_NONE};
        col->dtype_info = extra_info;

        RMM_ALLOC(&col->data, cudf::size_of(dtype) * num_rows, stream);
        if (allocate_bitmasks) {
          int fill_value = (all_valid) ? 0xff : 0;

          RMM_ALLOC(
              &col->valid,
              gdf_valid_allocation_size(num_rows) * sizeof(gdf_valid_type),
              stream);

          CUDA_TRY(cudaMemsetAsync(
              col->valid, fill_value,
              gdf_valid_allocation_size(num_rows) * sizeof(gdf_valid_type),
              stream));
        }
        return col;
      });
}

void table::destroy(void) {
  for (auto& col : _columns) {
    gdf_column_free(col);
    delete col;
  }
}

std::vector<gdf_dtype> column_dtypes(cudf::table const& table) {
  std::vector<gdf_dtype> dtypes(table.num_columns());

  std::transform(table.begin(), table.end(), dtypes.begin(),
                 [](gdf_column const* col) { return col->dtype; });
  return dtypes;
}

bool has_nulls(cudf::table const& table) {
  return std::any_of(table.begin(), table.end(), [](gdf_column const* col) {
    return (nullptr != col->valid) and (col->null_count > 0);
  });
}

}  // namespace cudf
