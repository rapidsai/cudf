diff --git a/cpp/src/io/json/json_column.cu b/cpp/src/io/json/json_column.cu
index 10646fad35..437c27d7a5 100644
--- a/cpp/src/io/json/json_column.cu
+++ b/cpp/src/io/json/json_column.cu
@@ -674,6 +674,7 @@ void make_device_json_column(device_span<SymbolT const> input,
             reinitialize_as_string(old_col_id, col);
             // all its children (which are already inserted) are ignored later.
           }
+          col.forced_as_string_column = true;
           columns.try_emplace(this_col_id, columns.at(old_col_id));
           continue;
         }
@@ -915,6 +916,8 @@ std::pair<std::unique_ptr<column>, std::vector<column_name_info>> device_json_co
                                          : "n/a");
 #endif
         target_type = schema.value().type;
+      } else if(json_col.forced_as_string_column) {
+        target_type = data_type{type_id::STRING};
       }
       // Infer column type, if we don't have an explicit type for it
       else {
diff --git a/cpp/src/io/json/nested_json.hpp b/cpp/src/io/json/nested_json.hpp
index f41b024bb1..64fffdb27f 100644
--- a/cpp/src/io/json/nested_json.hpp
+++ b/cpp/src/io/json/nested_json.hpp
@@ -160,6 +160,8 @@ struct device_json_column {
   std::vector<std::string> column_order;
   // Counting the current number of items in this column
   row_offset_t num_rows = 0;
+  // Force as string column
+  bool forced_as_string_column{false};
 
   /**
    * @brief Construct a new d json column object
